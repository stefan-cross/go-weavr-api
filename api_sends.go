/*
Weavr Multi Product API

Weavr Multi API provides a simple and flexible way to issue cards and accounts to your customers.  By integrating Weavr Multi API in your application you can embed banking capabilities within your app and provide a seamless experience for your customers.  # Authentication Each request to the Multi API must include an `api_key` that represents your account. You can obtain an API Key by registering for a Multi account [here](https://portal.weavr.io).  Almost all endpoints require a secondary authentication token `auth_token` that represents the user for whom the request is being executed. 

API version: 3.32.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package weavr

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SendsApiService SendsApi service
type SendsApiService service

type ApiSendCreateRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	transferCreateRequest *TransferCreateRequest
	idempotencyRef *interface{}
}

func (r ApiSendCreateRequest) TransferCreateRequest(transferCreateRequest TransferCreateRequest) ApiSendCreateRequest {
	r.transferCreateRequest = &transferCreateRequest
	return r
}

// A unique call reference generated by the caller that, taking into consideration the payload as well as the operation itself, helps avoid duplicate operations. Idempotency reference uniqueness is maintained for at least 24 hours.
func (r ApiSendCreateRequest) IdempotencyRef(idempotencyRef interface{}) ApiSendCreateRequest {
	r.idempotencyRef = &idempotencyRef
	return r
}

func (r ApiSendCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendCreateExecute(r)
}

/*
SendCreate Create a send transaction

Sends funds between managed accounts and managed cards belonging to *different* corporate or consumer identities.

The Send Profile (configured in the Multi Portal) specified determines the behaviour and restrictions of the transaction (for example, fees).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendCreateRequest
*/
func (a *SendsApiService) SendCreate(ctx context.Context) ApiSendCreateRequest {
	return ApiSendCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendsApiService) SendCreateExecute(r ApiSendCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transferCreateRequest == nil {
		return nil, reportError("transferCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyRef != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-ref", r.idempotencyRef, "")
	}
	// body params
	localVarPostBody = r.transferCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendGetRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	id interface{}
}

func (r ApiSendGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendGetExecute(r)
}

/*
SendGet Get a send transaction

Retrieve the send transaction identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the Send transaction.
 @return ApiSendGetRequest
*/
func (a *SendsApiService) SendGet(ctx context.Context, id interface{}) ApiSendGetRequest {
	return ApiSendGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SendsApiService) SendGetExecute(r ApiSendGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendSCAChallengeRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	id interface{}
	channel SCAOtpChannel
}

func (r ApiSendSCAChallengeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendSCAChallengeExecute(r)
}

/*
SendSCAChallenge Issue a one-time password that can be used to verify a send

Starts the verification process for a send in which a one-time password is sent to a device belonging to the logged-in user that was previously enrolled through the `/authentication_factors/otp/{channel}` endpoint.

You should only start this process if the send `state` is `PENDING_CHALLENGE`.

_Note that on the Sandbox Environment, text messages are not sent and the one-time-password is always \"123456\"._


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the send transaction.
 @param channel The unique identifier for the channel.
 @return ApiSendSCAChallengeRequest
*/
func (a *SendsApiService) SendSCAChallenge(ctx context.Context, id interface{}, channel SCAOtpChannel) ApiSendSCAChallengeRequest {
	return ApiSendSCAChallengeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *SendsApiService) SendSCAChallengeExecute(r ApiSendSCAChallengeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendSCAChallenge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends/{id}/challenges/otp/{channel}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendSCAChallengePushRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	id interface{}
	channel SCAPushChannel
}

func (r ApiSendSCAChallengePushRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendSCAChallengePushExecute(r)
}

/*
SendSCAChallengePush Issue a push notification that can be used to verify Send transaction

Starts the verification process for a Send in which a push notification is sent to a device belonging to the logged-in user that was previously enrolled through the `/authentication_factors/push/{channel}` endpoint.

You should only start this process if the Send transaction `state` is `PENDING_CHALLENGE`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the send transaction.
 @param channel
 @return ApiSendSCAChallengePushRequest
*/
func (a *SendsApiService) SendSCAChallengePush(ctx context.Context, id interface{}, channel SCAPushChannel) ApiSendSCAChallengePushRequest {
	return ApiSendSCAChallengePushRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *SendsApiService) SendSCAChallengePushExecute(r ApiSendSCAChallengePushRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendSCAChallengePush")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends/{id}/challenges/push/{channel}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendSCAVerifyRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	id interface{}
	channel SCAOtpChannel
	stepupSCAVerifyRequest *StepupSCAVerifyRequest
}

func (r ApiSendSCAVerifyRequest) StepupSCAVerifyRequest(stepupSCAVerifyRequest StepupSCAVerifyRequest) ApiSendSCAVerifyRequest {
	r.stepupSCAVerifyRequest = &stepupSCAVerifyRequest
	return r
}

func (r ApiSendSCAVerifyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendSCAVerifyExecute(r)
}

/*
SendSCAVerify Verify a send using a one-time password

Completes the verification process for a Send.

If the outcome of the verification is successful, the send is executed.

_Note that on the Sandbox Environment, text messages are not sent and the `verificationCode` is always \"123456\"._


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the send transaction.
 @param channel The unique identifier for the channel.
 @return ApiSendSCAVerifyRequest
*/
func (a *SendsApiService) SendSCAVerify(ctx context.Context, id interface{}, channel SCAOtpChannel) ApiSendSCAVerifyRequest {
	return ApiSendSCAVerifyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *SendsApiService) SendSCAVerifyExecute(r ApiSendSCAVerifyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendSCAVerify")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends/{id}/challenges/otp/{channel}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stepupSCAVerifyRequest == nil {
		return nil, reportError("stepupSCAVerifyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stepupSCAVerifyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendsGetRequest struct {
	ctx context.Context
	ApiService *SendsApiService
	offset *interface{}
	limit *interface{}
	profileId *interface{}
	instrumentId *InstrumentId
	sourceId *interface{}
	sourceType *InstrumentType
	state *interface{}
	createdFrom *interface{}
	createdTo *interface{}
	tag *interface{}
}

// The offset value for paging, indicating the initial item number to be returned from the data set satisfying the given criteria. Leave out to fetch the first page of results.
func (r ApiSendsGetRequest) Offset(offset interface{}) ApiSendsGetRequest {
	r.offset = &offset
	return r
}

// The limit of the results for paging, starting at the offset. Limit is always capped at 100.
func (r ApiSendsGetRequest) Limit(limit interface{}) ApiSendsGetRequest {
	r.limit = &limit
	return r
}

// Filter by the Send profile. Leave out to fetch all entries.
func (r ApiSendsGetRequest) ProfileId(profileId interface{}) ApiSendsGetRequest {
	r.profileId = &profileId
	return r
}

// Filter by the source instrument id.
func (r ApiSendsGetRequest) InstrumentId(instrumentId InstrumentId) ApiSendsGetRequest {
	r.instrumentId = &instrumentId
	return r
}

// Filter by the source instrument id. Must be specified when &#x60;source.type&#x60; is provided.
func (r ApiSendsGetRequest) SourceId(sourceId interface{}) ApiSendsGetRequest {
	r.sourceId = &sourceId
	return r
}

// Filter by the source instrument type. Must be specified when &#x60;source.id&#x60; is provided.
func (r ApiSendsGetRequest) SourceType(sourceType InstrumentType) ApiSendsGetRequest {
	r.sourceType = &sourceType
	return r
}

// Filter by the Send transaction state. Leave out to fetch all states.
func (r ApiSendsGetRequest) State(state interface{}) ApiSendsGetRequest {
	r.state = &state
	return r
}

// Filter for send transactions created after &#x60;createdFrom&#x60; timestamp. Timestamp is expressed in Epoch timestamp using millisecond precision. Leave out to fetch all Send transactions.
func (r ApiSendsGetRequest) CreatedFrom(createdFrom interface{}) ApiSendsGetRequest {
	r.createdFrom = &createdFrom
	return r
}

// Filter for send transactions created before &#x60;createdTo&#x60; timestamp. Timestamp is expressed in Epoch timestamp using millisecond precision. Leave out to fetch all Send transactions.
func (r ApiSendsGetRequest) CreatedTo(createdTo interface{}) ApiSendsGetRequest {
	r.createdTo = &createdTo
	return r
}

// Filter by the send tag. The exact tag must be provided, as wildcards are not supported. Leave out to fetch all entries.
func (r ApiSendsGetRequest) Tag(tag interface{}) ApiSendsGetRequest {
	r.tag = &tag
	return r
}

func (r ApiSendsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendsGetExecute(r)
}

/*
SendsGet Get all send transactions

Retrieves all the send transactions performed by the logged-in identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendsGetRequest
*/
func (a *SendsApiService) SendsGet(ctx context.Context) ApiSendsGetRequest {
	return ApiSendsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SendsApiService) SendsGetExecute(r ApiSendsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SendsApiService.SendsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.instrumentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instrumentId", r.instrumentId, "")
	}
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source.id", r.sourceId, "")
	}
	if r.sourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source.type", r.sourceType, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdFrom", r.createdFrom, "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdTo", r.createdTo, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
