/*
Weavr Multi Product API

Weavr Multi API provides a simple and flexible way to issue cards and accounts to your customers.  By integrating Weavr Multi API in your application you can embed banking capabilities within your app and provide a seamless experience for your customers.  # Authentication Each request to the Multi API must include an `api_key` that represents your account. You can obtain an API Key by registering for a Multi account [here](https://portal.weavr.io).  Almost all endpoints require a secondary authentication token `auth_token` that represents the user for whom the request is being executed. 

API version: 3.32.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package weavr

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ManagedCardsApiService ManagedCardsApi service
type ManagedCardsApiService service

type ApiManagedCardAssignRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	managedCardAssignRequest *ManagedCardAssignRequest
}

func (r ApiManagedCardAssignRequest) ManagedCardAssignRequest(managedCardAssignRequest ManagedCardAssignRequest) ApiManagedCardAssignRequest {
	r.managedCardAssignRequest = &managedCardAssignRequest
	return r
}

func (r ApiManagedCardAssignRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardAssignExecute(r)
}

/*
ManagedCardAssign Assign a managed card

If your application requires anonymous cards, Weavr will create a pool of cards that are initially not assigned to any identity.
This operation assigns one such previously created managed card from the card pool to the logged-in consumer or corporate identity.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiManagedCardAssignRequest
*/
func (a *ManagedCardsApiService) ManagedCardAssign(ctx context.Context) ApiManagedCardAssignRequest {
	return ApiManagedCardAssignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardAssignExecute(r ApiManagedCardAssignRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardAssign")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/assign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardAssignRequest == nil {
		return nil, reportError("managedCardAssignRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardAssignRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardBlockRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardBlockExecute(r)
}

/*
ManagedCardBlock Block a managed card

Blocks the managed card identified by the `id` path parameter. This is a reversible action and the card can be unblocked using the _managedCardUnblock_ operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of a managed card.
 @return ApiManagedCardBlockRequest
*/
func (a *ManagedCardsApiService) ManagedCardBlock(ctx context.Context, id interface{}) ApiManagedCardBlockRequest {
	return ApiManagedCardBlockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardBlockExecute(r ApiManagedCardBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/block"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardCreateRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	managedCardRequest *ManagedCardRequest
	idempotencyRef *interface{}
}

func (r ApiManagedCardCreateRequest) ManagedCardRequest(managedCardRequest ManagedCardRequest) ApiManagedCardCreateRequest {
	r.managedCardRequest = &managedCardRequest
	return r
}

// A unique call reference generated by the caller that, taking into consideration the payload as well as the operation itself, helps avoid duplicate operations. Idempotency reference uniqueness is maintained for at least 24 hours.
func (r ApiManagedCardCreateRequest) IdempotencyRef(idempotencyRef interface{}) ApiManagedCardCreateRequest {
	r.idempotencyRef = &idempotencyRef
	return r
}

func (r ApiManagedCardCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardCreateExecute(r)
}

/*
ManagedCardCreate Create a managed card

Creates a managed card for the consumer or corporate identity.
The Managed Card Profile (configured in the Multi Portal) specified determines the behaviour and restrictions that the managed card will have.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiManagedCardCreateRequest
*/
func (a *ManagedCardsApiService) ManagedCardCreate(ctx context.Context) ApiManagedCardCreateRequest {
	return ApiManagedCardCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardCreateExecute(r ApiManagedCardCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardRequest == nil {
		return nil, reportError("managedCardRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyRef != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-ref", r.idempotencyRef, "")
	}
	// body params
	localVarPostBody = r.managedCardRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardGetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardGetExecute(r)
}

/*
ManagedCardGet Get a managed card

Returns all details of the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of a card.
 @return ApiManagedCardGetRequest
*/
func (a *ManagedCardsApiService) ManagedCardGet(ctx context.Context, id interface{}) ApiManagedCardGetRequest {
	return ApiManagedCardGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardGetExecute(r ApiManagedCardGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalActivateRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	managedCardPhysicalActivateRequest *ManagedCardPhysicalActivateRequest
}

func (r ApiManagedCardPhysicalActivateRequest) ManagedCardPhysicalActivateRequest(managedCardPhysicalActivateRequest ManagedCardPhysicalActivateRequest) ApiManagedCardPhysicalActivateRequest {
	r.managedCardPhysicalActivateRequest = &managedCardPhysicalActivateRequest
	return r
}

func (r ApiManagedCardPhysicalActivateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalActivateExecute(r)
}

/*
ManagedCardPhysicalActivate Activate a physical card

Activates the physical card identified by the `id` path paramter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalActivateRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalActivate(ctx context.Context, id interface{}) ApiManagedCardPhysicalActivateRequest {
	return ApiManagedCardPhysicalActivateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalActivateExecute(r ApiManagedCardPhysicalActivateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalActivate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardPhysicalActivateRequest == nil {
		return nil, reportError("managedCardPhysicalActivateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardPhysicalActivateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalContactlessLimitResetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardPhysicalContactlessLimitResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalContactlessLimitResetExecute(r)
}

/*
ManagedCardPhysicalContactlessLimitReset Reset contactless limit for a physical card

For security purposes, the cardholder needs to provide the PIN after a number of contactless purchases. Use this operation to reset the physical card's contactless limit.
The contactless limit can only be reset for physical cards having the wearable form factor.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalContactlessLimitResetRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalContactlessLimitReset(ctx context.Context, id interface{}) ApiManagedCardPhysicalContactlessLimitResetRequest {
	return ApiManagedCardPhysicalContactlessLimitResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalContactlessLimitResetExecute(r ApiManagedCardPhysicalContactlessLimitResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalContactlessLimitReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/contactless_limit/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalPinGetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardPhysicalPinGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalPinGetExecute(r)
}

/*
ManagedCardPhysicalPinGet Get PIN for a physical card

Retrieves the PIN of the physical card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalPinGetRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalPinGet(ctx context.Context, id interface{}) ApiManagedCardPhysicalPinGetRequest {
	return ApiManagedCardPhysicalPinGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalPinGetExecute(r ApiManagedCardPhysicalPinGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalPinGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalPinUnBlockRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardPhysicalPinUnBlockRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalPinUnBlockExecute(r)
}

/*
ManagedCardPhysicalPinUnBlock Unblock PIN for a physical card

Physical cards can be marked as `pinBlocked` if there are too many failed PIN attempts.

Use this operation to unblock a PIN so that the card can be used again.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalPinUnBlockRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalPinUnBlock(ctx context.Context, id interface{}) ApiManagedCardPhysicalPinUnBlockRequest {
	return ApiManagedCardPhysicalPinUnBlockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalPinUnBlockExecute(r ApiManagedCardPhysicalPinUnBlockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalPinUnBlock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/pin/unblock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalReplaceDamagedRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	managedCardPhysicalReplaceDamagedRequest *ManagedCardPhysicalReplaceDamagedRequest
}

func (r ApiManagedCardPhysicalReplaceDamagedRequest) ManagedCardPhysicalReplaceDamagedRequest(managedCardPhysicalReplaceDamagedRequest ManagedCardPhysicalReplaceDamagedRequest) ApiManagedCardPhysicalReplaceDamagedRequest {
	r.managedCardPhysicalReplaceDamagedRequest = &managedCardPhysicalReplaceDamagedRequest
	return r
}

func (r ApiManagedCardPhysicalReplaceDamagedRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalReplaceDamagedExecute(r)
}

/*
ManagedCardPhysicalReplaceDamaged Replace a damaged physical card

Report as damaged, and replace the physical card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalReplaceDamagedRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalReplaceDamaged(ctx context.Context, id interface{}) ApiManagedCardPhysicalReplaceDamagedRequest {
	return ApiManagedCardPhysicalReplaceDamagedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalReplaceDamagedExecute(r ApiManagedCardPhysicalReplaceDamagedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalReplaceDamaged")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/replace_damaged"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardPhysicalReplaceDamagedRequest == nil {
		return nil, reportError("managedCardPhysicalReplaceDamagedRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardPhysicalReplaceDamagedRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalReplaceLostOrStolenRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	managedCardPhysicalReplaceLostOrStolenRequest *ManagedCardPhysicalReplaceLostOrStolenRequest
}

func (r ApiManagedCardPhysicalReplaceLostOrStolenRequest) ManagedCardPhysicalReplaceLostOrStolenRequest(managedCardPhysicalReplaceLostOrStolenRequest ManagedCardPhysicalReplaceLostOrStolenRequest) ApiManagedCardPhysicalReplaceLostOrStolenRequest {
	r.managedCardPhysicalReplaceLostOrStolenRequest = &managedCardPhysicalReplaceLostOrStolenRequest
	return r
}

func (r ApiManagedCardPhysicalReplaceLostOrStolenRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalReplaceLostOrStolenExecute(r)
}

/*
ManagedCardPhysicalReplaceLostOrStolen Replace a lost or stolen physical card

Issue a replacement for the physical card, identified by the `id` path parameter, that has already been reported as lost or stolen.

Any funds (that are not blocked pending a purchase for a previous authorisation) remaining on the card will be automatically transferred to the new replacement card.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalReplaceLostOrStolenRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalReplaceLostOrStolen(ctx context.Context, id interface{}) ApiManagedCardPhysicalReplaceLostOrStolenRequest {
	return ApiManagedCardPhysicalReplaceLostOrStolenRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalReplaceLostOrStolenExecute(r ApiManagedCardPhysicalReplaceLostOrStolenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalReplaceLostOrStolen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/replace_lost_stolen"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardPhysicalReplaceLostOrStolenRequest == nil {
		return nil, reportError("managedCardPhysicalReplaceLostOrStolenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardPhysicalReplaceLostOrStolenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalReportLostRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardPhysicalReportLostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalReportLostExecute(r)
}

/*
ManagedCardPhysicalReportLost Report a physical card as lost

Report the physical card identified by the `id` path parameter as lost. This will deactivate the instrument and a new card will need to be requested.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalReportLostRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalReportLost(ctx context.Context, id interface{}) ApiManagedCardPhysicalReportLostRequest {
	return ApiManagedCardPhysicalReportLostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalReportLostExecute(r ApiManagedCardPhysicalReportLostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalReportLost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/report_lost"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalReportStolenRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardPhysicalReportStolenRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalReportStolenExecute(r)
}

/*
ManagedCardPhysicalReportStolen Report a physical card as stolen

Report the physical card identified by the `id` path parameter as stolen. This will destroy the instrument and a new replacement card will need to be requested.

Once a replacement is requested, any funds remaining on this destroyed card will be transferred to the replacement card."


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalReportStolenRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalReportStolen(ctx context.Context, id interface{}) ApiManagedCardPhysicalReportStolenRequest {
	return ApiManagedCardPhysicalReportStolenRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalReportStolenExecute(r ApiManagedCardPhysicalReportStolenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalReportStolen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical/report_stolen"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardPhysicalUpgradeRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	managedCardPhysicalUpgradeRequest *ManagedCardPhysicalUpgradeRequest
}

func (r ApiManagedCardPhysicalUpgradeRequest) ManagedCardPhysicalUpgradeRequest(managedCardPhysicalUpgradeRequest ManagedCardPhysicalUpgradeRequest) ApiManagedCardPhysicalUpgradeRequest {
	r.managedCardPhysicalUpgradeRequest = &managedCardPhysicalUpgradeRequest
	return r
}

func (r ApiManagedCardPhysicalUpgradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardPhysicalUpgradeExecute(r)
}

/*
ManagedCardPhysicalUpgrade Upgrade a card to physical

Upgrades the virtual card identified by the `id` path parameter to physical.

Before cards can be upgraded, a physcial card programme must be set up and the card profile configuration updated accordingly.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardPhysicalUpgradeRequest
*/
func (a *ManagedCardsApiService) ManagedCardPhysicalUpgrade(ctx context.Context, id interface{}) ApiManagedCardPhysicalUpgradeRequest {
	return ApiManagedCardPhysicalUpgradeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardPhysicalUpgradeExecute(r ApiManagedCardPhysicalUpgradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardPhysicalUpgrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/physical"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardPhysicalUpgradeRequest == nil {
		return nil, reportError("managedCardPhysicalUpgradeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardPhysicalUpgradeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardRemoveRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardRemoveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardRemoveExecute(r)
}

/*
ManagedCardRemove Remove a managed card

Destroys the managed card identified by the `id` path parameter. Unlike block, this action is not reversible.

A managed card must be empty before it can be destroyed using this operation.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of a managed card.
 @return ApiManagedCardRemoveRequest
*/
func (a *ManagedCardsApiService) ManagedCardRemove(ctx context.Context, id interface{}) ApiManagedCardRemoveRequest {
	return ApiManagedCardRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardRemoveExecute(r ApiManagedCardRemoveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardRemove")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardSpendRulesCreateRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	body *interface{}
}

func (r ApiManagedCardSpendRulesCreateRequest) Body(body interface{}) ApiManagedCardSpendRulesCreateRequest {
	r.body = &body
	return r
}

func (r ApiManagedCardSpendRulesCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardSpendRulesCreateExecute(r)
}

/*
ManagedCardSpendRulesCreate Create spend rules for a managed card

Create the spend rules associated with the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardSpendRulesCreateRequest
*/
func (a *ManagedCardsApiService) ManagedCardSpendRulesCreate(ctx context.Context, id interface{}) ApiManagedCardSpendRulesCreateRequest {
	return ApiManagedCardSpendRulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardSpendRulesCreateExecute(r ApiManagedCardSpendRulesCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardSpendRulesCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/spend_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardSpendRulesDeleteRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardSpendRulesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardSpendRulesDeleteExecute(r)
}

/*
ManagedCardSpendRulesDelete Delete all spend rules for a managed card

Remove all spend rules associated with the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardSpendRulesDeleteRequest
*/
func (a *ManagedCardsApiService) ManagedCardSpendRulesDelete(ctx context.Context, id interface{}) ApiManagedCardSpendRulesDeleteRequest {
	return ApiManagedCardSpendRulesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardSpendRulesDeleteExecute(r ApiManagedCardSpendRulesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardSpendRulesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/spend_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardSpendRulesGetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardSpendRulesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardSpendRulesGetExecute(r)
}

/*
ManagedCardSpendRulesGet Get all spend rules for a managed card

Fetch the list of spend rules associated with the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardSpendRulesGetRequest
*/
func (a *ManagedCardsApiService) ManagedCardSpendRulesGet(ctx context.Context, id interface{}) ApiManagedCardSpendRulesGetRequest {
	return ApiManagedCardSpendRulesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardSpendRulesGetExecute(r ApiManagedCardSpendRulesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardSpendRulesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/spend_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardSpendRulesSetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	body *interface{}
}

func (r ApiManagedCardSpendRulesSetRequest) Body(body interface{}) ApiManagedCardSpendRulesSetRequest {
	r.body = &body
	return r
}

func (r ApiManagedCardSpendRulesSetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardSpendRulesSetExecute(r)
}

/*
ManagedCardSpendRulesSet Set spend rules for a managed card

Set the spend rules associated with the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardSpendRulesSetRequest

Deprecated
*/
func (a *ManagedCardsApiService) ManagedCardSpendRulesSet(ctx context.Context, id interface{}) ApiManagedCardSpendRulesSetRequest {
	return ApiManagedCardSpendRulesSetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
// Deprecated
func (a *ManagedCardsApiService) ManagedCardSpendRulesSetExecute(r ApiManagedCardSpendRulesSetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardSpendRulesSet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/spend_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardSpendRulesUpdateRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	body *interface{}
}

func (r ApiManagedCardSpendRulesUpdateRequest) Body(body interface{}) ApiManagedCardSpendRulesUpdateRequest {
	r.body = &body
	return r
}

func (r ApiManagedCardSpendRulesUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardSpendRulesUpdateExecute(r)
}

/*
ManagedCardSpendRulesUpdate Update spend rules for a managed card

Must be user after a POST, to update individual spend rules associated with the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiManagedCardSpendRulesUpdateRequest
*/
func (a *ManagedCardsApiService) ManagedCardSpendRulesUpdate(ctx context.Context, id interface{}) ApiManagedCardSpendRulesUpdateRequest {
	return ApiManagedCardSpendRulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardSpendRulesUpdateExecute(r ApiManagedCardSpendRulesUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardSpendRulesUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/spend_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardStatementRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	accept *interface{}
	offset *interface{}
	limit *interface{}
	orderByTimestamp *interface{}
	fromTimestamp *interface{}
	toTimestamp *interface{}
}

// A request parameter specifying the type of response the client would like. Must be one of &#x60;application/json&#x60;, &#x60;application/pdf&#x60; or &#x60;text/csv&#x60;.  The default response type (&#x60;application/json&#x60;) will be returned if specified incorrectly or not specified. 
func (r ApiManagedCardStatementRequest) Accept(accept interface{}) ApiManagedCardStatementRequest {
	r.accept = &accept
	return r
}

// The offset value for paging, indicating the initial item number to be returned from the data set satisfying the given criteria. Leave out to fetch the first page of results.
func (r ApiManagedCardStatementRequest) Offset(offset interface{}) ApiManagedCardStatementRequest {
	r.offset = &offset
	return r
}

// The limit of the results for paging, starting at the offset. Limit is always capped at 100.
func (r ApiManagedCardStatementRequest) Limit(limit interface{}) ApiManagedCardStatementRequest {
	r.limit = &limit
	return r
}

// Orders the result in ascending or descending order.   - ASC: Ascending order, oldest transactions first.   - DESC: Descending order, most recent transactions first.  If not specified, the transactions will be returned in descending order. 
func (r ApiManagedCardStatementRequest) OrderByTimestamp(orderByTimestamp interface{}) ApiManagedCardStatementRequest {
	r.orderByTimestamp = &orderByTimestamp
	return r
}

// Filter for transactions having transaction timestamp after &#x60;fromTimestamp&#x60;. Timestamp is expressed in Epoch timestamp using millisecond precision.
func (r ApiManagedCardStatementRequest) FromTimestamp(fromTimestamp interface{}) ApiManagedCardStatementRequest {
	r.fromTimestamp = &fromTimestamp
	return r
}

// Filter for transactions having transaction timestamp before the &#x60;toTimestamp&#x60;. Timestamp is expressed in Epoch timestamp using millisecond precision.
func (r ApiManagedCardStatementRequest) ToTimestamp(toTimestamp interface{}) ApiManagedCardStatementRequest {
	r.toTimestamp = &toTimestamp
	return r
}

func (r ApiManagedCardStatementRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardStatementExecute(r)
}

/*
ManagedCardStatement Get a managed card statement

Returns a list of transactions against the managed card identified by the `id` path parameter, matching the criteria provided in the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of a managed card.
 @return ApiManagedCardStatementRequest
*/
func (a *ManagedCardsApiService) ManagedCardStatement(ctx context.Context, id interface{}) ApiManagedCardStatementRequest {
	return ApiManagedCardStatementRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardStatementExecute(r ApiManagedCardStatementRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardStatement")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/statement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.orderByTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderByTimestamp", r.orderByTimestamp, "")
	}
	if r.fromTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimestamp", r.fromTimestamp, "")
	}
	if r.toTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimestamp", r.toTimestamp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "accept", r.accept, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardUnblockRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
}

func (r ApiManagedCardUnblockRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardUnblockExecute(r)
}

/*
ManagedCardUnblock Unblock a managed card

Unblocks the managed card identified by the `id` path parameter.
The managed card must have `state.blockedReason` as `USER` so that it can be unblocked.
If the managed card was blocked by `SYSTEM`, users cannot unblock it.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the managed card.
 @return ApiManagedCardUnblockRequest
*/
func (a *ManagedCardsApiService) ManagedCardUnblock(ctx context.Context, id interface{}) ApiManagedCardUnblockRequest {
	return ApiManagedCardUnblockRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardUnblockExecute(r ApiManagedCardUnblockRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardUnblock")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}/unblock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardUpdateRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	id interface{}
	managedCardUpdateRequest *ManagedCardUpdateRequest
}

func (r ApiManagedCardUpdateRequest) ManagedCardUpdateRequest(managedCardUpdateRequest ManagedCardUpdateRequest) ApiManagedCardUpdateRequest {
	r.managedCardUpdateRequest = &managedCardUpdateRequest
	return r
}

func (r ApiManagedCardUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardUpdateExecute(r)
}

/*
ManagedCardUpdate Update a managed card

Update the details of the managed card identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of a card.
 @return ApiManagedCardUpdateRequest
*/
func (a *ManagedCardsApiService) ManagedCardUpdate(ctx context.Context, id interface{}) ApiManagedCardUpdateRequest {
	return ApiManagedCardUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardUpdateExecute(r ApiManagedCardUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.managedCardUpdateRequest == nil {
		return nil, reportError("managedCardUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managedCardUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManagedCardsGetRequest struct {
	ctx context.Context
	ApiService *ManagedCardsApiService
	offset *interface{}
	limit *interface{}
	profileId *interface{}
	friendlyName *interface{}
	state *interface{}
	stateBlockedReason *interface{}
	stateDestroyedReason *interface{}
	currency *interface{}
	type_ *interface{}
	externalHandle *interface{}
	cardNumberFirstSix *interface{}
	cardNumberLastFour *interface{}
	createdFrom *interface{}
	createdTo *interface{}
	mode *interface{}
	tag *interface{}
	parentManagedAccountId *interface{}
	manufacturingState *interface{}
}

// The offset value for paging, indicating the initial item number to be returned from the data set satisfying the given criteria. Leave out to fetch the first page of results.
func (r ApiManagedCardsGetRequest) Offset(offset interface{}) ApiManagedCardsGetRequest {
	r.offset = &offset
	return r
}

// The limit of the results for paging, starting at the offset. Limit is always capped at 100.
func (r ApiManagedCardsGetRequest) Limit(limit interface{}) ApiManagedCardsGetRequest {
	r.limit = &limit
	return r
}

// Filter by the managed account/card profile. Leave out to fetch all managed accounts/card.
func (r ApiManagedCardsGetRequest) ProfileId(profileId interface{}) ApiManagedCardsGetRequest {
	r.profileId = &profileId
	return r
}

// Filter by the managed account/card friendly name. Leave out to fetch all managed accounts/card.  The exact name must be provided, as wildcards are not supported. 
func (r ApiManagedCardsGetRequest) FriendlyName(friendlyName interface{}) ApiManagedCardsGetRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiManagedCardsGetRequest) State(state interface{}) ApiManagedCardsGetRequest {
	r.state = &state
	return r
}

func (r ApiManagedCardsGetRequest) StateBlockedReason(stateBlockedReason interface{}) ApiManagedCardsGetRequest {
	r.stateBlockedReason = &stateBlockedReason
	return r
}

func (r ApiManagedCardsGetRequest) StateDestroyedReason(stateDestroyedReason interface{}) ApiManagedCardsGetRequest {
	r.stateDestroyedReason = &stateDestroyedReason
	return r
}

// Filter by the managed account/card currency.  Currencies are expressed as an ISO 4217 code. Leave out to fetch all managed accounts/card. 
func (r ApiManagedCardsGetRequest) Currency(currency interface{}) ApiManagedCardsGetRequest {
	r.currency = &currency
	return r
}

// Filter by the type of the card.
func (r ApiManagedCardsGetRequest) Type_(type_ interface{}) ApiManagedCardsGetRequest {
	r.type_ = &type_
	return r
}

// Search by the card&#39;s &#x60;externalHandle&#x60;.
func (r ApiManagedCardsGetRequest) ExternalHandle(externalHandle interface{}) ApiManagedCardsGetRequest {
	r.externalHandle = &externalHandle
	return r
}

// Filter by first six digits of the card.
func (r ApiManagedCardsGetRequest) CardNumberFirstSix(cardNumberFirstSix interface{}) ApiManagedCardsGetRequest {
	r.cardNumberFirstSix = &cardNumberFirstSix
	return r
}

// Filter by last four digits of the card.
func (r ApiManagedCardsGetRequest) CardNumberLastFour(cardNumberLastFour interface{}) ApiManagedCardsGetRequest {
	r.cardNumberLastFour = &cardNumberLastFour
	return r
}

// Filter for managed accounts/cards created after &#x60;createdFrom&#x60; timestamp. Timestamp is expressed in Epoch timestamp using millisecond precision. Leave out to fetch all managed accounts/cards.
func (r ApiManagedCardsGetRequest) CreatedFrom(createdFrom interface{}) ApiManagedCardsGetRequest {
	r.createdFrom = &createdFrom
	return r
}

// Filter for managed accounts/cards created before &#x60;createdTo&#x60; timestamp. Timestamp is expressed in Epoch timestamp using millisecond precision. Leave out to fetch all managed accounts/cards.
func (r ApiManagedCardsGetRequest) CreatedTo(createdTo interface{}) ApiManagedCardsGetRequest {
	r.createdTo = &createdTo
	return r
}

// Filter by card mode (prepaid mode or debit mode).
func (r ApiManagedCardsGetRequest) Mode(mode interface{}) ApiManagedCardsGetRequest {
	r.mode = &mode
	return r
}

// Filter by the managed account/card tag. The exact tag must be provided, as wildcards are not supported. Leave out to fetch all managed accounts/card.
func (r ApiManagedCardsGetRequest) Tag(tag interface{}) ApiManagedCardsGetRequest {
	r.tag = &tag
	return r
}

// Filter by the Id of the parent managed account associated with the card. This is applicable only for debit mode cards.
func (r ApiManagedCardsGetRequest) ParentManagedAccountId(parentManagedAccountId interface{}) ApiManagedCardsGetRequest {
	r.parentManagedAccountId = &parentManagedAccountId
	return r
}

func (r ApiManagedCardsGetRequest) ManufacturingState(manufacturingState interface{}) ApiManagedCardsGetRequest {
	r.manufacturingState = &manufacturingState
	return r
}

func (r ApiManagedCardsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManagedCardsGetExecute(r)
}

/*
ManagedCardsGet Get all managed cards

Fetch cards matching the search criteria provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiManagedCardsGetRequest
*/
func (a *ManagedCardsApiService) ManagedCardsGet(ctx context.Context) ApiManagedCardsGetRequest {
	return ApiManagedCardsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ManagedCardsApiService) ManagedCardsGetExecute(r ApiManagedCardsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedCardsApiService.ManagedCardsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/managed_cards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendlyName", r.friendlyName, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.stateBlockedReason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state.blockedReason", r.stateBlockedReason, "")
	}
	if r.stateDestroyedReason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state.destroyedReason", r.stateDestroyedReason, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.externalHandle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalHandle", r.externalHandle, "")
	}
	if r.cardNumberFirstSix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberFirstSix", r.cardNumberFirstSix, "")
	}
	if r.cardNumberLastFour != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLastFour", r.cardNumberLastFour, "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdFrom", r.createdFrom, "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdTo", r.createdTo, "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.parentManagedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentManagedAccountId", r.parentManagedAccountId, "")
	}
	if r.manufacturingState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturingState", r.manufacturingState, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
