/*
Weavr Multi Product API

Weavr Multi API provides a simple and flexible way to issue cards and accounts to your customers.  By integrating Weavr Multi API in your application you can embed banking capabilities within your app and provide a seamless experience for your customers.  # Authentication Each request to the Multi API must include an `api_key` that represents your account. You can obtain an API Key by registering for a Multi account [here](https://portal.weavr.io).  Almost all endpoints require a secondary authentication token `auth_token` that represents the user for whom the request is being executed. 

API version: 3.32.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package weavr

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OutgoingWireTransfersApiService OutgoingWireTransfersApi service
type OutgoingWireTransfersApiService service

type ApiOutgoingWireTransferCreateRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	outgoingWireTransferCreateRequest *OutgoingWireTransferCreateRequest
	idempotencyRef *interface{}
}

func (r ApiOutgoingWireTransferCreateRequest) OutgoingWireTransferCreateRequest(outgoingWireTransferCreateRequest OutgoingWireTransferCreateRequest) ApiOutgoingWireTransferCreateRequest {
	r.outgoingWireTransferCreateRequest = &outgoingWireTransferCreateRequest
	return r
}

// A unique call reference generated by the caller that, taking into consideration the payload as well as the operation itself, helps avoid duplicate operations. Idempotency reference uniqueness is maintained for at least 24 hours.
func (r ApiOutgoingWireTransferCreateRequest) IdempotencyRef(idempotencyRef interface{}) ApiOutgoingWireTransferCreateRequest {
	r.idempotencyRef = &idempotencyRef
	return r
}

func (r ApiOutgoingWireTransferCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransferCreateExecute(r)
}

/*
OutgoingWireTransferCreate Create an outgoing wire transfer transaction

Transfers funds from managed accounts to an external bank account.

The Outgoing Wire Transfer Profile (configured in the Multi Portal) specified determines the behaviour and restrictions of the transaction (for example, fees).

Note that even if the transaction is created successfully, you still need to check its state in order to determine if it is pending completion of an authentication challenge by the user. 


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOutgoingWireTransferCreateRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferCreate(ctx context.Context) ApiOutgoingWireTransferCreateRequest {
	return ApiOutgoingWireTransferCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferCreateExecute(r ApiOutgoingWireTransferCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransferCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.outgoingWireTransferCreateRequest == nil {
		return nil, reportError("outgoingWireTransferCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.idempotencyRef != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-ref", r.idempotencyRef, "")
	}
	// body params
	localVarPostBody = r.outgoingWireTransferCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutgoingWireTransferGetRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	id interface{}
}

func (r ApiOutgoingWireTransferGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransferGetExecute(r)
}

/*
OutgoingWireTransferGet Get an outgoing wire transfer transaction

Retrieves the outgoing wire transfer identified by the `id` path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the Outgoing Wire Transfer transaction.
 @return ApiOutgoingWireTransferGetRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferGet(ctx context.Context, id interface{}) ApiOutgoingWireTransferGetRequest {
	return ApiOutgoingWireTransferGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferGetExecute(r ApiOutgoingWireTransferGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransferGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutgoingWireTransferSCAChallengeRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	id interface{}
	channel SCAOtpChannel
}

func (r ApiOutgoingWireTransferSCAChallengeRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransferSCAChallengeExecute(r)
}

/*
OutgoingWireTransferSCAChallenge Issue a one-time password that can be used to verify an outgoing wire transfer

Starts the verification process for an outgoing wire transfer in which a one-time password is sent to a device belonging to the logged-in user that was previously enrolled through the `/authentication_factors/otp/{channel}` endpoint.

You should only start this process if the outgoing wire transfer `state` is `PENDING_CHALLENGE`.

_Note that on the Sandbox Environment, text messages are not sent and the one-time-password is always \"123456\"._


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the Outgoing Wire Transfer transaction.
 @param channel The unique identifier for the channel.
 @return ApiOutgoingWireTransferSCAChallengeRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAChallenge(ctx context.Context, id interface{}, channel SCAOtpChannel) ApiOutgoingWireTransferSCAChallengeRequest {
	return ApiOutgoingWireTransferSCAChallengeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAChallengeExecute(r ApiOutgoingWireTransferSCAChallengeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransferSCAChallenge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers/{id}/challenges/otp/{channel}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutgoingWireTransferSCAChallengePushRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	id interface{}
	channel SCAPushChannel
}

func (r ApiOutgoingWireTransferSCAChallengePushRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransferSCAChallengePushExecute(r)
}

/*
OutgoingWireTransferSCAChallengePush Issue a push notification that can be used to verify an outgoing wire transfer

Starts the verification process for an outgoing wire transfer in which a push notification is sent to a device belonging to the logged-in user that was previously enrolled through the `/authentication_factors/push/{channel}` endpoint.

You should only start this process if the outgoing wire transfer `state` is `PENDING_CHALLENGE`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the Outgoing Wire Transfer transaction.
 @param channel
 @return ApiOutgoingWireTransferSCAChallengePushRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAChallengePush(ctx context.Context, id interface{}, channel SCAPushChannel) ApiOutgoingWireTransferSCAChallengePushRequest {
	return ApiOutgoingWireTransferSCAChallengePushRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAChallengePushExecute(r ApiOutgoingWireTransferSCAChallengePushRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransferSCAChallengePush")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers/{id}/challenges/push/{channel}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutgoingWireTransferSCAVerifyRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	id interface{}
	channel SCAOtpChannel
	stepupSCAVerifyRequest *StepupSCAVerifyRequest
}

func (r ApiOutgoingWireTransferSCAVerifyRequest) StepupSCAVerifyRequest(stepupSCAVerifyRequest StepupSCAVerifyRequest) ApiOutgoingWireTransferSCAVerifyRequest {
	r.stepupSCAVerifyRequest = &stepupSCAVerifyRequest
	return r
}

func (r ApiOutgoingWireTransferSCAVerifyRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransferSCAVerifyExecute(r)
}

/*
OutgoingWireTransferSCAVerify Verify an outgoing wire transfer using a one-time password

Completes the verification process for an outgoing wire transfer.

If the outcome of the verification is successful, the outgoing wire transfer transaction is executed.

_Note that on the Sandbox Environment, text messages are not sent and the `verificationCode` is always \"123456\"._


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the Outgoing Wire Transfer transaction.
 @param channel The unique identifier for the channel.
 @return ApiOutgoingWireTransferSCAVerifyRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAVerify(ctx context.Context, id interface{}, channel SCAOtpChannel) ApiOutgoingWireTransferSCAVerifyRequest {
	return ApiOutgoingWireTransferSCAVerifyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		channel: channel,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransferSCAVerifyExecute(r ApiOutgoingWireTransferSCAVerifyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransferSCAVerify")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers/{id}/challenges/otp/{channel}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stepupSCAVerifyRequest == nil {
		return nil, reportError("stepupSCAVerifyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stepupSCAVerifyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOutgoingWireTransfersGetRequest struct {
	ctx context.Context
	ApiService *OutgoingWireTransfersApiService
	offset *interface{}
	limit *interface{}
	profileId *interface{}
	instrument *interface{}
	sourceInstrumentId *interface{}
	sourceInstrumentType *SourceInstrumentType
	state *interface{}
	createdFrom *interface{}
	createdTo *interface{}
	tag *interface{}
}

// The offset value for paging, indicating the initial item number to be returned from the data set satisfying the given criteria. Leave out to fetch the first page of results.
func (r ApiOutgoingWireTransfersGetRequest) Offset(offset interface{}) ApiOutgoingWireTransfersGetRequest {
	r.offset = &offset
	return r
}

// The limit of the results for paging, starting at the offset. Limit is always capped at 100.
func (r ApiOutgoingWireTransfersGetRequest) Limit(limit interface{}) ApiOutgoingWireTransfersGetRequest {
	r.limit = &limit
	return r
}

// Filter by the managed account/card profile. Leave out to fetch all managed accounts/card.
func (r ApiOutgoingWireTransfersGetRequest) ProfileId(profileId interface{}) ApiOutgoingWireTransfersGetRequest {
	r.profileId = &profileId
	return r
}

// Filter by the source instrument id (which must be a managed account).
func (r ApiOutgoingWireTransfersGetRequest) Instrument(instrument interface{}) ApiOutgoingWireTransfersGetRequest {
	r.instrument = &instrument
	return r
}

// Filter by the source instrument id. Must be specified when &#x60;source.type&#x60; is provided.
func (r ApiOutgoingWireTransfersGetRequest) SourceInstrumentId(sourceInstrumentId interface{}) ApiOutgoingWireTransfersGetRequest {
	r.sourceInstrumentId = &sourceInstrumentId
	return r
}

// Filter by the source instrument type. Must be specified when &#x60;source.id&#x60; is provided.
func (r ApiOutgoingWireTransfersGetRequest) SourceInstrumentType(sourceInstrumentType SourceInstrumentType) ApiOutgoingWireTransfersGetRequest {
	r.sourceInstrumentType = &sourceInstrumentType
	return r
}

// Filter by the outgoing wire transfer state. Leave out to fetch all states.
func (r ApiOutgoingWireTransfersGetRequest) State(state interface{}) ApiOutgoingWireTransfersGetRequest {
	r.state = &state
	return r
}

// Filter for outgoing wire transfer transactions created after &#x60;createdFrom&#x60; timestamp, expressed in Epoch timestamp using millisecond precision. Leave out to fetch all outgoing wire transfer transactions.
func (r ApiOutgoingWireTransfersGetRequest) CreatedFrom(createdFrom interface{}) ApiOutgoingWireTransfersGetRequest {
	r.createdFrom = &createdFrom
	return r
}

// Filter for Outgoing Wire Transfer transactions created before &#x60;createdTo&#x60; timestamp, expressed in Epoch timestamp using millisecond precision. Leave out to fetch all outgoing wire transfer transactions.
func (r ApiOutgoingWireTransfersGetRequest) CreatedTo(createdTo interface{}) ApiOutgoingWireTransfersGetRequest {
	r.createdTo = &createdTo
	return r
}

// Filter by the outgoing wire transfer tag. The exact tag must be provided, as wildcards are not supported. Leave out to fetch all entries.
func (r ApiOutgoingWireTransfersGetRequest) Tag(tag interface{}) ApiOutgoingWireTransfersGetRequest {
	r.tag = &tag
	return r
}

func (r ApiOutgoingWireTransfersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.OutgoingWireTransfersGetExecute(r)
}

/*
OutgoingWireTransfersGet Get all outgoing wire transfer transactions

Retrieves all the outgoing wire transfer transactions performed by the logged-in identity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOutgoingWireTransfersGetRequest
*/
func (a *OutgoingWireTransfersApiService) OutgoingWireTransfersGet(ctx context.Context) ApiOutgoingWireTransfersGetRequest {
	return ApiOutgoingWireTransfersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OutgoingWireTransfersApiService) OutgoingWireTransfersGetExecute(r ApiOutgoingWireTransfersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OutgoingWireTransfersApiService.OutgoingWireTransfersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outgoing_wire_transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.instrument != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instrument", r.instrument, "")
	}
	if r.sourceInstrumentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceInstrument.id", r.sourceInstrumentId, "")
	}
	if r.sourceInstrumentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceInstrument.type", r.sourceInstrumentType, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdFrom", r.createdFrom, "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdTo", r.createdTo, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
